// Copyright (c) 2024 the authors
// Use of this source code is governed by a MIT license found in the LICENSE file.

package assistant

import (
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"

	"github.com/ktong/assistant/embedded"
)

const (
	// RoleUser indicates the message is sent by an actual user and
	// should be used in most cases to represent user-generated messages.
	RoleUser Role = "user"
	// RoleAssistant indicates the message is generated by the assistant.
	// Use this value to insert messages from the assistant into the conversation.
	RoleAssistant Role = "assistant"
)

type (
	// Message created by an Assistant or a user.
	Message struct {
		// Role of the entity that is creating the message.
		Role Role
		// Content parts with a defined type, each can be of type text or images.
		// Image types are only supported on Vision-compatible models.
		Content []Content
		// Tools that are for files attached to the message for specific tools.
		Tools []BuiltInTool
	}

	Role    string
	Content interface {
		embedded.Content
	}
)

func (m Message) MarshalJSON() ([]byte, error) {
	type Attachment struct {
		FileID string          `json:"file_id"`
		Tools  []embedded.Tool `json:"tools"`
	}
	var attachments []*Attachment
	appendFiles := func(tool embedded.Tool, files []File) {
	fileLoop:
		for _, file := range files {
			for _, attachment := range attachments {
				if attachment.FileID == file.ID {
					attachment.Tools = append(attachment.Tools, tool)

					continue fileLoop
				}
			}
			attachments = append(attachments, &Attachment{FileID: file.ID, Tools: []embedded.Tool{tool}})
		}
	}
	for _, tool := range m.Tools {
		if codeInterpreter, ok := tool.(CodeInterpreter); ok {
			appendFiles(codeInterpreter, codeInterpreter.Files)
		}
	}

	return json.Marshal(map[string]any{ //nolint:wrapcheck
		"role":        m.Role,
		"content":     m.Content,
		"attachments": attachments,
	})
}

// Text content that is part of a message.
type Text struct {
	embedded.Content

	// Text content to be sent to the model.
	Text string
}

func (t Text) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf(`{"type":"text","text":"%s"}`, t.Text)), nil
}

const (
	DetailAuto Detail = "auto"
	DetailLow  Detail = "low"
	DetailHigh Detail = "high"
)

type (
	// Image is a references an image File or URL in the content of a message.
	Image[F string | []byte] struct {
		embedded.Content

		// URL to the File ID or external URL of the image in the message content.
		// Set purpose="vision" when uploading the File if you need to later display the file content.
		URL F
		// Detail specifies the detail level of the image.
		Detail Detail
	}

	Detail string
)

func (i Image[F]) MarshalJSON() ([]byte, error) {
	const (
		fileFormat = `{"type":"image_file","image_file":{"file_id":"%s","detail":"%s"}}`
		urlFormat  = `{"type":"image_url","image_url":{"url":"%s","detail":"%s"}}`
	)

	if data, ok := any(i.URL).([]byte); ok {
		mime := http.DetectContentType(data)
		switch mime {
		case "image/gif", "image/jpeg", "image/pjpeg":
			maxEncLen := base64.StdEncoding.EncodedLen(len(data))
			buf := make([]byte, maxEncLen) //nolint:makezero
			base64.StdEncoding.Encode(buf, data)
			u := fmt.Sprintf("Data:%s;base64,%s", mime, buf)

			return []byte(fmt.Sprintf(urlFormat, u, i.Detail)), nil
		default:
			return nil, fmt.Errorf("unsupported image type: %s", mime) //nolint:err113
		}
	}

	parsedURL, err := url.Parse(string(i.URL))
	if err != nil {
		return nil, fmt.Errorf("parse image URL: %w", err)
	}
	switch parsedURL.Scheme {
	case "", "file":
		return []byte(fmt.Sprintf(fileFormat, parsedURL.Path, i.Detail)), nil
	default:
		return []byte(fmt.Sprintf(urlFormat, i.URL, i.Detail)), nil
	}
}
